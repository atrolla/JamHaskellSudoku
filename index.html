<!DOCTYPE html>
<html>
  <head>
    <title>Jam Haskell</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      
      .footnote {
        position: absolute;
        bottom: 3em;
        right : 10em;
        font-size: 75%;
        font-style: italic;
        text-align: right
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Jam Haskell 
Side Effects Shall Receive No Mercy! (Partie 1)

https://github.com/atrolla/JamHaskellSudoku


.footnote[http://www.meetup.com/fr-FR/Jams-de-code/events/235099329/<br/>
Jam Arolla - 2016/11/03 by Yvan Vu & Benoit Chiquet]
---
class: middle

# Concepts

1. Pure Functional Programming
2. Types
3. Higher Order Functions
4. Lazy Evaluation

---
class: center, middle
# Goal

Solve a Sudoku a la Richard Bird

http://www.cs.tufts.edu/~nr/cs257/archive/richard-bird/sudoku.pdf

---
class: center
#Sudoku

![Sudoku Grid Image Here](https://upload.wikimedia.org/wikipedia/commons/f/ff/Sudoku-by-L2G-20050714.svg "Sudoku Grid")

_The objective is to **fill a 9x9 grid** with digits so that **each column, each row, and each of the nine 3x3 subgrids** that compose the grid ("boxes") contains all of the digits **from 1 to 9 exactly once**_.

---
class: center
#Sudoku

![Sudoku Grid Solved Image Here](https://upload.wikimedia.org/wikipedia/commons/3/31/Sudoku-by-L2G-20050714_solution.svg "Sudoku Grid Solved")
---
class: center, middle

# Step 1

Make it work
---
# Types & Constants

```haskell
type Matrix a = [Row a]
type Row a = [a]
type Grid = Matrix Digit
type Digit = Char

gridSize :: Num a => a
gridSize = 9

boxSize :: Num a => a
boxSize = 3

cellValues :: [Char]
cellValues = ['1'..'9']

isBlank :: Digit -> Bool
isBlank = (=='.')
```
.footnote[Step 1]
---
class: center

![Sudoku Step 1](https://atrolla.github.io/JamHaskellSudoku/images/sudokuStep1.png "Sudoku Grid")

Let's start with a very simple sudoku for a very simple solution

.footnote[Step 1]
---
```haskell
sudokuStep1 :: Grid
sudokuStep1 = [
  "753186942",
  "914237865",
  "62859.731",
  "289.536.7",
  "375861294",
  "146729358",
  "891342576",
  "462975183",
  "537618429"
  ]
```

#### Approach :

1. For each blank cell, we put every possible values.
2. Then we combine all the cell choices to have every possible grid combination.
3. Finally, we filter all the valid grids following the rules and we take the first grid.

```haskell
solve :: Grid -> Grid
solve = head . filter correct . combine . choices
```
.footnote[Step 1]
---
#correct

```haskell
correct :: Grid -> Bool
correct grid = all noDuplicates (rows grid) &&
          all noDuplicates (cols grid) &&
          all noDuplicates (boxes grid)

noDuplicates :: Eq a => [a] -> Bool
noDuplicates = undefined -- TODO
          
rows :: Matrix a -> Matrix a         
rows = id

cols :: Matrix a -> Matrix a
cols = undefined -- TODO

boxes :: Matrix a -> Matrix a
boxes = undefined

group :: [a] -> [[a]]
group = undefined  -- TODO

ungroup :: [[a]] -> [a]
ungroup = undefined -- TODO

combine = undefined
choices = undefined
```
.footnote[Step 1]
---
# boxes
```xml
["123456789","123456789","123456789",...]

> group each line by 3 cells (transform each line)

[["123","456","789"],["123","456","789"],["123","456","789"],...]

> group the grid by 3 lines

[[["123","456","789"],["123","456","789"],["123","456","789"]],...]

> gather the columns (in each group of 3 lines)

[[["123","123","123"],["456","456","456"],["789","789","789"]],...]

> ungroup the 3 lines 

[["123","123","123"],["456","456","456"],["789","789","789"],...]

> ungroup the 3 cells (in each almost-box)

["123123123","456456456","789789789",...]

boxes = map ungroup . ungroup . map cols . group . map group
```
.footnote[Step 1]
---
# Tips

```haskell
filter :: (a -> Bool) -> [a] -> [a] -- signature, parameters type order
filter _pred []    = [] -- pattern matching
filter pred (x:xs)
  | pred x         = x : filter pred xs  -- pattern matching with guards
  | otherwise      = filter pred xs

filter (>3) [1,2,3,4,5] -- = [4,5]  
all (/=3) [1,2,4,5,6,7,8,9,3] -- = False
map (+1) [1,2,3,4,5] -- = [2,3,4,5,6]
take 6 [1..] -- = [1,2,3,4,5,6]
take 4 $ drop 3 [1,3..] -- = [7,9,11,13]
elem 1 [3,4,2,5,1,7,8,9] -- = True
sequence [[1,2,3]] -- = [[1],[2],[3]]

concat [[1,2,3],[4,5,6]] -- [1,2,3,4,5,6]
not True -- = False 

notElem = not elem 
filter (`elem` ["apple","banana"]) ["orange","pinapple","banana","raspberry"]
-- = ["banana"]

[(i,j) | i <- [1,2], j <- [1..4] ] -- list comprehension
-- = [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4)]
```

.footnote[Step 1]
---
# choices

replace blank entries with all possible values
```haskell
choices :: Grid -> Matrix [Digit]
choices = map (map choice)

choice :: Digit -> [ Digit ]
choice = undefined -- TODO
```

# combine

cartesian product of every choices
```haskell
combine :: Matrix [a] -> [Matrix a]
combine = undefined -- TODO
```

.footnote[Step 1]
---
class: center, middle

# Our solution is extremely efficient !
![Trollface](http://static.mmzstatic.com/wp-content/uploads/2012/01/trollface-meme.jpg)

9 ^ (number of blank entries)

.footnote[Step 1]
---
class: center, middle

# Step 2

Make it right
---

# pruning

A better choice for a blank entry in row r, column c and box b is any cell value that **does not appear** among the fixed entries in row r, column c or box b.

_reduce_ removes fixed entry from a group (row, col, box) of choices
```haskell
reduce :: [[Digit]] -> [[Digit]]
reduce css = map (remove (fixed css)) css
```
_fixed_ filters the fix entries from a a group of choices
```haskell
fixed :: [[Digit]] -> [Digit]
fixed = undefined -- TODO
```
_remove_ takes a list of fix entries and remove them from a choice (list a possibilities)
```haskell
remove :: [Digit] -> [Digit] -> [Digit]
remove fs css = undefined -- TODO
```

.footnote[Step 2]
---

# prune - the math part

```haskell
prune :: Matrix [Digit] -> Matrix [Digit]
```
satisfying (in solve function)
```xml
filter correct . combine = filter correct . combine . prune
```
(we don't like maths so here is the conclusion)
```haskell
prune = pruneBy boxes . pruneBy cols . pruneBy rows

pruneBy :: (Matrix [Digit] -> Matrix [Digit])->(Matrix [Digit] -> Matrix [Digit])
pruneBy f = f . map reduce . f -- if f . f = id
```
UNDER THE CONDITION :
```xml
rows . rows = id
cols . cols = id
boxes . boxes = id
```

.footnote[Step 2]
---
class: center, middle
# How to check those conditions ?
.footnote[Step 2]

--
### Romeu says : "PBT!!!"


---
class: middle
# .center[Everything is fine...]

.center[Try comparing pruning effect in **ghci**, show time with option]
```xml
:l prune.hs
:set +s
```
.footnote[Step 2]
---
class: center, middle

# Step 3

Make it fast
---
# .center[single cell expansion]

- matrix combination is a little overkill

- we can recall prune till the prune x = x

.footnote[Step 3]

--
### .center[change combination for a more effective strategy and use prune]

After pruning, we expand list of choices of a cell into a list of matrix.

Repeat the process till completion.

---
#complete & safe

when expanding, a matrix can be

- complete : all choices are singleton
```haskell
complete :: Matrix [Digit] -> Bool
complete = all (all single)
    where 
        single :: [a] -> Bool
        single = undefined
```
- safe : there are no duplicates in the fixed entries
```haskell
safe :: Matrix [Digit] -> Bool
safe = undefined (almost like correct)
```

#### a valid matrix which lead to a valid grid is complete and safe.

.footnote[Step 3]
---
# expand

![epxnad image](https://atrolla.github.io/JamHaskellSudoku/images/expand.png)

It is better to expand from a not fixed cell with the smallest number of choices.
So first let's find what is that smallest number.

```haskell
minimalChoices :: [[[a]]] -> Int
minimalChoices = minimum . undefined  -- TODO

-- tips
-- use length / concat
```

.footnote[Step 3]
---
# expand

```haskell
expand :: Matrix [Digit] -> [ Matrix [Digit] ]
expand matrix = [rowsBefore ++ [rowBeforeChoice ++ [c] 
 : rowAfterChoice] ++ rowsAfter | c <- cellchoices] -- same line
  where
    (rowsBefore, rowOfMinimal : rowsAfter)            = undefined -- TODO
    -- identify a row containing a smallest minimal choices cell
    (rowBeforeChoice,  cellchoices  : rowAfterChoice) = undefined -- TODO
    -- identify the cell with the smallest minimal choices in the rowOfMinimal
    smallest cellValues                               = undefined -- TODO
    -- predicate to know if a cell has the smallest minimal choices
```

#### (Pro) Tips
```haskell
break :: (a -> Bool) -> [a] -> ([a], [a]) Source #
-- break, applied to a predicate p and a list xs, returns a tuple 
-- where first element is longest prefix (possibly empty) of xs of elements 
-- that do not satisfy p and second element is the remainder of the list:
break (> 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])

any (==5) [1,2,3,4,5,6,7,8,9] -- = True
```
.footnote[Step 3]
---
# single cell expand - the math part

Now we have the equality
```xml
combine = concat . map combine . expand
```
_(under the condition of discarding complete and unsafe matrix and not in the same order)_

```sql
filter correct . combine
= filter correct . concat . map combine . expand
= concat . map (filter correct . combine) . expand
-- filter p . concat = concat . map (filter p)
= concat . map (filter correct . combine . prune) . expand
-- prune property (filter correct . combine = filter correct . combine . prune)
```

```haskell
search :: Matrix [Digit] -> [Grid]
search satisfies (filter correct . combine . prune)
```

```xml
search . prune = concat . map search . expand
```

.footnote[Step 3]
---
# search cases

complete search
```haskell
search :: Matrix [Digit] -> [Grid]
```
- matrix not safe ? 
```haskell
(no grid - throw away)
```
- pruned matrix complete ? 
```haskell
(extract the grid) = map (map head)
```
- otherwise ? 
```haskell
concat . map search . expand1
```

.footnote[Step 3]
---
class: middle
# .center[final version ]

```haskell
solve :: Grid -> Grid
solve = head . search . choices

hardSudoku :: Grid
hardSudoku = [
  "..73....6",
  ".2..5..7.",
  "4....79..",
  "5....42..",
  ".1..6..8.",
  "..28....5",
  "..46....8",
  ".9..3..1.",
  "2....87.."
  ]
```
.footnote[Step 3]
---
class: center, middle
# Thank you !

    </textarea>
    <script src="https://atrolla.github.io/JamHaskellSudoku/javascript/remark.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>